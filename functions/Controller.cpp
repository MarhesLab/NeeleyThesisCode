#include "Controller.h"

#include "autopilot.h" // radsToDMC()

/*
	PID Attitude Gains	

	Gains derived from discrete integral LQR applied to the 
	attitude part of A and B matrices
	Anew = [A(7:12,7:12)]
	Bnew = [B(7:12,2:4)]
	Q = diag([100 100 1 10 10 1]);
	R = diag([10 10 100])
	Ts = 0.01
	M = 0.650
	Jq = diag([0.00365,0.00368,0.00703])
	Lq = 0.17
	Bq = 6.11 e -8 N/(rpm^2)
	Kq = 1.50 e -9 N*m/(rpm^2)
*/

const double Kp_OX = 0.8438, Kp_OY = 0.8500, Kp_OZ = 0.0924;
const double Kd_OX = 0.2782, Kd_OY = 0.2802, Kd_OZ = 0.0992;
//const double Ki_OX = 0.0556, Ki_OY = 0.0556, Ki_OZ = 0.0867;

/*
	PID Position Gains

	Gains derived from discrete integral LQR applied to a simplified
	point-mass model with external X/Y force inputs; These get mapped
	into desired Euler angles based on the currently executed thrust
	and the 
	A = [0 0 1 0 0 0 	B = [ 0   0
	     0 0 0 1 0 0 	      0   0
	     0 0 0 0 0 0 	      1/M 0
         0 0 0 0 0 0 	      0   1/M]
	Q = diag([10 10 10 10])
	R = diag([10 10])
	Ts = 0.01
	M = 0.650
*/

const double Kp_X = 0.9884, Kp_Y = 0.9884, Kp_Z = 3;
const double Kd_X = 1.5039, Kd_Y = 1.5039, Kd_Z = 4.2;
//const double Ki_X = 0.3113, Ki_Y = 0.3113, Ki_Z = 0.3113;


Controller::Controller(double *Xq_in, double *XqTraj_in, double *XqRef_in, 
		double *Uq_cmd_in, double *Uq_act_in, double* omegas_in, 
		unsigned char* motorDMCs_in, int quad_index)
{
	// Initializes class-defined arrays
	for(int i = 0; i < STATES; i++) {
		XqRefErr[i] = 0;
		XqRefErrInt[i] = 0;
	}

	// Passes the State, Reference, and Inputs
	Xq 	= Xq_in;
	XqTraj  = XqTraj_in;
	XqRef 	= XqRef_in;
	Uq_cmd 	= Uq_cmd_in;
	Uq_act 	= Uq_act_in;
	omegas = omegas_in;
	motorDMCs = motorDMCs_in;
	
	// Gathers appropriate quadrotor parameters based on the quadrotor number given
	Mq   = Mq_meas[quad_index];
	dCGx = CG_off_x[quad_index];
	dCGy = CG_off_y[quad_index];
	Lq   = Lq_meas[quad_index];
	Bp   = Bp_calc[quad_index];
	Kp   = Kp_calc[quad_index];

	// Sets up the YawOptimizer object
	yawOpt.makeModel(Bp, Kp, Lq);	// sets up the optimization model based on the given values
	yawOpt.useSimplexPrimal();	// Simplex method typically converges in one iteration

	// Sets up the feedback linearization controller
	initializeStruct(fstruct, 0);
}


// Nothing needed for the destructor
Controller::~Controller()
{

}


void Controller::calcRefError()
{
	// Calculates the error
	for(int i = 0; i < STATES; i++)
		XqRefErr[i] = XqRef[i] - Xq[i];

	// Integrates the error for select states
	XqRefErrInt[ X] += Ts*XqRefErr[ X];
	XqRefErrInt[ Y] += Ts*XqRefErr[ Y];
	XqRefErrInt[ Z] += Ts*XqRefErr[ Z];
}


void Controller::calcRefErrorNoIntegral()
{
	// Calculates the error
	for(int i = 0; i < STATES; i++)
		XqRefErr[i] = XqRef[i] - Xq[i];
}


// Returns a Boolean variable indicating if the quadrotor
// can execute the given input
bool Controller::inputIsValid()
{
	// Converts input to motor speeds
	inputsToMotorSpeeds(Uq_act, omegas, Lq, Bp, Kp);

	// Checks resulting motor speeds; if any exceed their limits,
	// INVALID
	for(int i = 0; i < MOTORS; i++) {
		if(omegas[i] < omega_min)
			return false;
		if(omegas[i] > omega_max)
			return false;
	}

	// If all the previous checks passed, it's good to go!
	return true;
}

void Controller::limitInputs()
{
	// Saturates the thrust to prevent it from going crazy
	if(Uq_act[Th] > 15)
		Uq_act[Th] = 15;
	else if(Uq_act[Th] < 2)
		Uq_act[Th] = 2;

	// If commanded yaw torque is larger than 0, check to make sure it isn't too high,
	// as that can lead to undesired thrust behaviors.
	if(Uq_act[Tz] > 0) {
		yawOpt.inputUpdate(Uq_act);
		yawOpt.findMax();

		if(yawOpt.isValidMax()) {	// if it can find a feasible max yaw...
			if(Uq_act[Tz] > yawOpt.getMax())	// ..and if the commanded yaw exceeds that...			
				Uq_act[Tz] = yawOpt.getMax(); // set it to the max
			//else
			//	Uq_act[Tz] = Uq_act[Tz];
		}
		else	// if there's no feasible max yaw...
			Uq_act[Tz] = 0;	// set it to 0 and see what happens
	}
	// Same as above, but in the opposite direction
	else if(Uq_act[Tz] < 0) {
		yawOpt.inputUpdate(Uq_act);
		yawOpt.findMin();

		if(yawOpt.isValidMin()) {
			if(Uq_act[Tz] < yawOpt.getMin())			
				Uq_act[Tz] = yawOpt.getMin();
			//else
			//	Uq_act[Tz] = Uq_act[Tz];
		}
		else
			Uq_act[Tz] = 0;
	}
	// if it's just zero, don't worry about anything
	//else
	//	Uq_act[Tz] = 0;
}


void Controller::limitMotors()
{
	for(int i = 0; i < MOTORS; i++) {
		if (omegas[i] < omega_min)
			omegas[i] = omega_min;
		else if (omegas[i] > omega_max)
			omegas[i] = omega_max;		
	}
}


// Compensates for the torque generated by the center of gravity (CG)
// not being in the middle of the quadrotor arms
void Controller::compCGoffset()
{
	// Rotates the weight vector based on orientation
	double weight[3] = {0, 0, -Mq*G}, weight_rot[3];
	quatRot(weight, weight_rot, &Xq[Q0]);
	
	// Calculates the CG offset's created torque
	double cg_torque_x =  dCGy*weight_rot[2];
	double cg_torque_y = -dCGx*weight_rot[2];
	double cg_torque_z =  dCGx*weight_rot[1] - dCGy*weight_rot[0];

	// Subtracts off the contributed torque to cancel it out
	Uq_act[Tx] = Uq_act[Tx] - cg_torque_x;
	Uq_act[Ty] = Uq_act[Ty] - cg_torque_y;
	Uq_act[Tz] = Uq_act[Tz] - cg_torque_z;
}


void Controller::generateMotorSpeeds()
{
	this->limitInputs();
	inputsToMotorSpeeds(Uq_act, omegas, Lq, Bp, Kp);
}


void Controller::generateDMCs()
{
	this->limitMotors();
	for(int i = 0; i < MOTORS; i++)
		motorDMCs[i] = radsToDMC(omegas[i]);
}


void Controller::defaultThrust()
{
	// Sets the thrust to constant values for testing purposes.
	Uq_cmd[Th] = 6.0; // Newtons of thrust force
	Uq_act[Th] = Uq_cmd[Th];	
}


void Controller::defaultAngleRef()
{
	// Converts the current reference quaternion to Euler angles
	double euler[3];
	quat2EulerZYX(&XqRef[Q0], euler); 
	
	// Sets the XY angles to 0
	euler[0] = 0;
	euler[1] = 0;

	// Converts the reference Euler angles back to a quaternion
	eulerZYX2Quat(euler, &XqRef[Q0]);
}


void Controller::attitudeControlPD()
{
	// Converts the quaternion to Euler angles for easier control
	double euler[3], eulerRef[3], eulerError[3];
	quat2EulerZYX(&Xq[Q0], euler);
	quat2EulerZYX(&XqRef[Q0], eulerRef);

	for(int i = 0; i < 3; i++)
		eulerError[i] = eulerRef[i] - euler[i];

	// Roll Control
	Uq_cmd[Tx] = Kp_OX*eulerError[0] + Kd_OX*XqRefErr[WX];
	
	// Pitch Control
	Uq_cmd[Ty] = Kp_OY*eulerError[1] + Kd_OY*XqRefErr[WY];

	// Yaw Control
	Uq_cmd[Tz] = Kp_OZ*eulerError[2] + Kd_OZ*XqRefErr[WZ];

	// Sets the actual torques to be equal to the commanded torques
	Uq_act[Tx] = Uq_cmd[Tx];
	Uq_act[Ty] = Uq_cmd[Ty];
	Uq_act[Tz] = Uq_cmd[Tz];
}


void Controller::altitudeControlPID()
{
	// Converts the quaternion to Euler angles
	double euler[3];
	quat2EulerZYX(&Xq[Q0], euler);

	double Fdes_Z;
	Fdes_Z = Kp_Z*XqRefErr[Z] + Kd_Z*XqRefErr[DZ];
	
	Uq_cmd[Th] = (Fdes_Z + Mq*G)/(cos(euler[0]) * cos(euler[1]));

	// Sets the actual thrust to be equal to the commanded thrust
	Uq_act[Th] = Uq_cmd[Th];
}


void Controller::positionControlPID()
{
	// Calculates desired World frame forces based on position
	// and velocity errors
	double Fdes_X, Fdes_Y, invThrust;	
	Fdes_X = Kp_X*XqRefErr[X] + Kd_X*XqRefErr[DX];
	Fdes_Y = Kp_Y*XqRefErr[Y] + Kd_Y*XqRefErr[DY];
	//invThrust = 1.0/Uq_cmd[Th];
	invThrust = 0.25; // went from inverse of thrust to a tunable scaling factor

	// Maps the desired World frame forces to desired OX/OY states,
	// with a few assumptions:
	//	- Only factors in the yaw angle
	//	- Linearizes around the origin with respect to OX and OY
	//		(cos(var) -> 1, sin(var) -> var)
	double euler[3], eulerRef[3];
	quat2EulerZYX(&Xq[Q0], euler);
	quat2EulerZYX(&XqRef[Q0], eulerRef);
	
	double cos_oz = cos(euler[2]);
	double sin_oz = sin(euler[2]);

	eulerRef[0] = sin_oz*(Fdes_X*invThrust) - cos_oz*(Fdes_Y*invThrust);
	eulerRef[1] = cos_oz*(Fdes_X*invThrust) + sin_oz*(Fdes_Y*invThrust);
	
	// Limits reference angles to within a relatively safe range
	if(eulerRef[0] > pi/6)
		eulerRef[0] = pi/6;
	else if(eulerRef[0] < -pi/6)
		eulerRef[0] = -pi/6;
		
	if(eulerRef[1] > pi/6)
		eulerRef[1] = pi/6;
	else if(eulerRef[1] < -pi/6)
		eulerRef[1] = -pi/6;

	// Converts the Euler angle reference back into a quaternion
	eulerZYX2Quat(eulerRef, &XqRef[Q0]);
}

// All of the function calls present in this function can be found in "feedbackLin.cpp".
//
// This set of calculations is quite dense. For an idea of what's even going on here,
// read these two papers first:
//	- O. Fritsch, P. De Monte, M. Buhl, and B. Lohmann, 
//		"Quasi-static feedback linearization for the translational dynamics 
//		 of a quadrotor helicopter"
// 	- M. Buhl and B. Lohmann, 
//		"Control with exponentially decaying Lyapunov functions and its use 
//		 for systems with input saturation"
void Controller::feedbackLinController()
{
	// Breaks the quaternion apart into XY and Z components
	splitQuaternion(Xq, fstruct);
	
	// Calculates the "auxiliary" frame angular velocities
	getAuxAngVels(Xq, fstruct);
	
	// Finds the derivatives of the split quaternion
	getSplitQuatDerivs(fstruct);

	// Finds the thrust and accelerations of the quadrotor
	getSecondDerivs(Xq, XqTraj, fstruct);

	// Finds the jerks of the quadrotor
	getThirdDerivs(Xq, XqTraj, fstruct);

	// Calculates the desired quaternion accelerations
	getQuatAccels(Xq, XqTraj, fstruct);

	// Calculates the desired "auxiliary" frame angular accelerations
	getWauxDots(fstruct);

	// Calculates the desired Body frame X and Y angular velocities
	getWxyDots(Xq, fstruct);

	// Performs heading control to find the desired Z angular velocity
	headingControl(XqTraj, fstruct);

	// Finally finds the desired inputs (thrust/torques) for the system
	getTrueInputs(Xq, Uq_cmd, fstruct);

	// Sets the actual values to be equal to the commanded values
	for(int i = 0; i < INPUTS; i++)
		Uq_act[i] = Uq_cmd[i];
}
